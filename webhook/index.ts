import { createWriteStream } from 'fs'

import { v4 as uuidv4 } from 'uuid'
import express from 'express'
import execa from 'execa'
import Bugsnag from '@bugsnag/js'
import BugsnagPluginExpress from '@bugsnag/plugin-express'

import { WebhookConfig, exists } from './utils'

const { mkdir, readdir, readFile, writeJSON } = require('fs-promise')

const {
  BUGSNAG_APP_TYPE,
  BUGSNAG_RELEASE_STAGE,
  EXPRESS_BUGSNAG_NOTIFIER_KEY,
  TEMP_DIR
} = require('../consts.json')

// fs-promise only exports cjs

// Bugsnag will automatically report errors from Express via a wrapper.
Bugsnag.start({
  apiKey: EXPRESS_BUGSNAG_NOTIFIER_KEY,
  appType: BUGSNAG_APP_TYPE,
  appVersion: require('../package.json').version,
  plugins: [BugsnagPluginExpress],
  releaseStage: BUGSNAG_RELEASE_STAGE
})

// Check version before continuing
if (parseInt(process.versions.node) < 16) {
  throw Error('Node version must be 16 or greater')
}

const app: express.Application = express()
const bugsnagMiddleware = Bugsnag.getPlugin('express')

const PORT = 3000

// Add bugsnag middleware to automatically catch errors
app.use(bugsnagMiddleware.requestHandler)
app.use(express.json())
app.use(bugsnagMiddleware.errorHandler)

/**
 * POST HTTP Endpoint. Requires specific objects in the request body, delivered by Datatools-server
 * job designed to work with this endpoint.
 * Will fail otherwise
 *
 * @param {Object} req  Express request object. Must contain manifest.json in the body
 * @param {Object} res  Express response object
 */
app.post('/webhook', async (req: express.Request, res: express.Response) => {
  // Validate body
  if (!req.body || (!req.body.gtfsFeeds && !req.body.csvFiles)) {
    const response = {
      error: 'Body of request must include gtfsFeeds or csvFiles.'
    }
    res.status(400).send(JSON.stringify(response))
    return
  }

  // Ensure temporary directory exists before writing to it
  if (!(await exists(TEMP_DIR))) {
    await mkdir(TEMP_DIR)
  }

  // Generate unique id for this execution
  const workerId: string = uuidv4()

  // Write config for config processor to file which it will read
  const processConfig: WebhookConfig = { ...req.body, workerId }
  const configFilePath = `${TEMP_DIR}input-${workerId}.json`
  await writeJSON(configFilePath, processConfig)

  // Spawn worker which updates pelias
  execa('node', ['processConfig.js', configFilePath], {
    all: true,
    detached: true
  }).all.pipe(createWriteStream(`logs/pelias-update-log-${workerId}.txt`))

  res.send(JSON.stringify({ workerId }))
  res.status(200).end()
})

/**
 * Endpoint to view status files generated by the detached process
 */
app.get(
  '/webhook/status/:id',
  async (req: express.Request, res: express.Response) => {
    const { id } = req.params

    // Since we're opening a file based on user input, we need to be careful
    const files: Array<string> = await readdir('logs')
    if (!files.includes(`status-${id}.json`)) {
      res.status(400).send(
        // Need to imitate status object
        JSON.stringify({
          completed: false,
          error: 'Could not find status file',
          message: ''
        })
      )
      return
    }
    const contents: string = await readFile(`logs/status-${id}.json`)

    res.write(contents)
    res.status(200).end()
  }
)

app.listen(PORT, () =>
  console.log(`Pelias update webhook server running on port ${PORT}`)
)
